// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: readings.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const insertReading = `-- name: InsertReading :one
INSERT INTO readings (device_id, ts, temperature_c, pressure_kpa, rpm, vibration, payload)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, device_id, ts, temperature_c, pressure_kpa, rpm, vibration, payload
`

type InsertReadingParams struct {
	DeviceID     pgtype.UUID
	Ts           pgtype.Timestamptz
	TemperatureC pgtype.Float8
	PressureKpa  pgtype.Float8
	Rpm          pgtype.Float8
	Vibration    pgtype.Float8
	Payload      []byte
}

func (q *Queries) InsertReading(ctx context.Context, arg InsertReadingParams) (Reading, error) {
	row := q.db.QueryRow(ctx, insertReading,
		arg.DeviceID,
		arg.Ts,
		arg.TemperatureC,
		arg.PressureKpa,
		arg.Rpm,
		arg.Vibration,
		arg.Payload,
	)
	var i Reading
	err := row.Scan(
		&i.ID,
		&i.DeviceID,
		&i.Ts,
		&i.TemperatureC,
		&i.PressureKpa,
		&i.Rpm,
		&i.Vibration,
		&i.Payload,
	)
	return i, err
}

const listReadingsForDevice = `-- name: ListReadingsForDevice :many
SELECT id, device_id, ts, temperature_c, pressure_kpa, rpm, vibration, payload FROM readings
WHERE device_id = $1 AND ts >= $2
ORDER BY ts DESC
LIMIT $3
`

type ListReadingsForDeviceParams struct {
	DeviceID pgtype.UUID
	Ts       pgtype.Timestamptz
	Limit    int32
}

func (q *Queries) ListReadingsForDevice(ctx context.Context, arg ListReadingsForDeviceParams) ([]Reading, error) {
	rows, err := q.db.Query(ctx, listReadingsForDevice, arg.DeviceID, arg.Ts, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Reading
	for rows.Next() {
		var i Reading
		if err := rows.Scan(
			&i.ID,
			&i.DeviceID,
			&i.Ts,
			&i.TemperatureC,
			&i.PressureKpa,
			&i.Rpm,
			&i.Vibration,
			&i.Payload,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
