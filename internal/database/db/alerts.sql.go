// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: alerts.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const ackAlert = `-- name: AckAlert :exec
UPDATE alerts
SET acknowledged_at = now()
WHERE id = $1 AND acknowledged_at IS NULL
`

func (q *Queries) AckAlert(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, ackAlert, id)
	return err
}

const createAlert = `-- name: CreateAlert :one
INSERT INTO alerts (device_id, alert_type, severity, message, fingerprint, context)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, device_id, alert_type, severity, message, triggered_at, acknowledged_at, resolved_at, active, fingerprint, context
`

type CreateAlertParams struct {
	DeviceID    uuid.UUID
	AlertType   string
	Severity    string
	Message     string
	Fingerprint string
	Context     []byte
}

func (q *Queries) CreateAlert(ctx context.Context, arg CreateAlertParams) (Alert, error) {
	row := q.db.QueryRow(ctx, createAlert,
		arg.DeviceID,
		arg.AlertType,
		arg.Severity,
		arg.Message,
		arg.Fingerprint,
		arg.Context,
	)
	var i Alert
	err := row.Scan(
		&i.ID,
		&i.DeviceID,
		&i.AlertType,
		&i.Severity,
		&i.Message,
		&i.TriggeredAt,
		&i.AcknowledgedAt,
		&i.ResolvedAt,
		&i.Active,
		&i.Fingerprint,
		&i.Context,
	)
	return i, err
}

const listAlerts = `-- name: ListAlerts :many
SELECT id, device_id, alert_type, severity, message, triggered_at, acknowledged_at, resolved_at, active, fingerprint, context FROM alerts
WHERE ($1::bool IS NULL OR active = $1)
  AND ($2::text IS NULL OR severity = $2)
  AND ($3::uuid IS NULL OR device_id = $3)
ORDER BY triggered_at DESC
LIMIT $4 OFFSET $5
`

type ListAlertsParams struct {
	Column1 bool
	Column2 string
	Column3 uuid.UUID
	Limit   int32
	Offset  int32
}

func (q *Queries) ListAlerts(ctx context.Context, arg ListAlertsParams) ([]Alert, error) {
	rows, err := q.db.Query(ctx, listAlerts,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Alert
	for rows.Next() {
		var i Alert
		if err := rows.Scan(
			&i.ID,
			&i.DeviceID,
			&i.AlertType,
			&i.Severity,
			&i.Message,
			&i.TriggeredAt,
			&i.AcknowledgedAt,
			&i.ResolvedAt,
			&i.Active,
			&i.Fingerprint,
			&i.Context,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resolveAlertByFingerprint = `-- name: ResolveAlertByFingerprint :exec
UPDATE alerts
SET active = false, resolved_at = now()
WHERE fingerprint = $1 AND active = true
`

func (q *Queries) ResolveAlertByFingerprint(ctx context.Context, fingerprint string) error {
	_, err := q.db.Exec(ctx, resolveAlertByFingerprint, fingerprint)
	return err
}
